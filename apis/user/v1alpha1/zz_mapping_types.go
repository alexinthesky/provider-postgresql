/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type MappingObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type MappingParameters struct {

	// This clause specifies the options of the user mapping. The options typically define the actual user name and password of the mapping. Option names must be unique. The allowed option names and values are specific to the server's foreign-data wrapper.
	// This clause specifies the options of the user mapping. The options typically define the actual user name and password of the mapping. Option names must be unique. The allowed option names and values are specific to the server's foreign-data wrapper
	// +kubebuilder:validation:Optional
	Options map[string]*string `json:"options,omitempty" tf:"options,omitempty"`

	// The name of an existing server for which the user mapping is to be created.
	// Changing this value
	// will force the creation of a new resource as this value can only be set
	// when the user mapping is created.
	// The name of an existing server for which the user mapping is to be created
	// +kubebuilder:validation:Required
	ServerName *string `json:"serverName" tf:"server_name,omitempty"`

	// The name of an existing user that is mapped to foreign server. CURRENT_ROLE, CURRENT_USER, and USER match the name of the current user. When PUBLIC is specified, a so-called public mapping is created that is used when no user-specific mapping is applicable.
	// Changing this value
	// will force the creation of a new resource as this value can only be set
	// when the user mapping is created.
	// The name of an existing user that is mapped to foreign server. CURRENT_ROLE, CURRENT_USER, and USER match the name of the current user. When PUBLIC is specified, a so-called public mapping is created that is used when no user-specific mapping is applicable
	// +kubebuilder:validation:Required
	UserName *string `json:"userName" tf:"user_name,omitempty"`
}

// MappingSpec defines the desired state of Mapping
type MappingSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     MappingParameters `json:"forProvider"`
}

// MappingStatus defines the observed state of Mapping.
type MappingStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        MappingObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Mapping is the Schema for the Mappings API. Creates and manages a user mapping on a PostgreSQL server.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,postgresql}
type Mapping struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              MappingSpec   `json:"spec"`
	Status            MappingStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// MappingList contains a list of Mappings
type MappingList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Mapping `json:"items"`
}

// Repository type metadata.
var (
	Mapping_Kind             = "Mapping"
	Mapping_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Mapping_Kind}.String()
	Mapping_KindAPIVersion   = Mapping_Kind + "." + CRDGroupVersion.String()
	Mapping_GroupVersionKind = CRDGroupVersion.WithKind(Mapping_Kind)
)

func init() {
	SchemeBuilder.Register(&Mapping{}, &MappingList{})
}
